<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
      <title>
        Netzwerk
      </title>
      <meta property="og:title" content="Netzwerk">
    <meta charset="utf-8">
    <meta property="og:type" content="article">

      <meta property="og:description" content="my description">
      <meta property="description" content="my description">


    <link rel="stylesheet" href="static/idyll_styles.css">
  </head>
  <body>
    <div id="idyll-mount"><div data-reactroot=""><div class="idyll-root"><div style="max-width:600px;margin-top:0;margin-right:0;margin-bottom:0;margin-left:50px" class=" idyll-text-container"><div class="article-header"><h1 class="hed">KÜRZESTE WEGE IN NETZWERKEN</h1><h2 class="dek">Am Beispiel des Floyd-Warshall Algorithmus</h2><div class="byline">By: <a>Duc, Thomas, Ben</a></div></div><div class="fixed"><p><h3>Klicke zwei Knoten an</h3></p><div style="width:100%"></div></div><h2>Was ist ein Netzwerk?</h2><p>Ein Netzwerk besteht aus einer Menge von eindeutigen Punkten, die Knoten genannt werden.</p><p><span class="isvg pending"></span><br/>
Diese Knoten können durch sogenannte Kanten verbunden sein. Gilt die Kante zwischen zwei Knoten
für beide Richtungen, so spricht man von einem ungerichteten Graphen</p><span class="isvg pending"></span><p>Im Gegenteil kann auch eine Kante nur für eine Richtung gelten. Deshalb wird der folgende Graph auch
gerichteter Graph genannt.</p><span class="isvg pending"></span><p>Außerdem kann jede Kante ein Gewicht haben. Das nächste Bild zeigt einen vollständigen Graphen.</p><span class="isvg pending"></span><p>Jedes Netzwerk ist definiert durch die Anzahl der Knoten und die Kanten, welche sie verbinden. Dadurch kann man
zu jeden Netzwerk eine Matrix angeben, die die Verbindungen des Netzwerks abbildet. Diese Matrix wird <a url="https://de.wikipedia.org/wiki/Adjazenzmatrix" href="https://de.wikipedia.org/wiki/Adjazenzmatrix">Adjazenzmatrix</a> genannt. Der Matrixeintrag mit Spalte 1 und Zeile 2
gibt dann das Gewicht der Verbindung von Knoten 1 zum Knoten 2 an. Gibt es keine Verbindung von 1 nach 2, dann wird das Gewicht als
unendlich aufgefasst.<div style="width:100%"></div></p><h2>Dynamische Programmierung</h2><p>Dynamische Programmierung ist eine Methode zum algorithmischen Lösen eines Optimierungsproblems, indem dieses in gleichartige Teilprobleme zerlegt wird und die Zwischenresultaten systematische gespeichert werden.
Wie die Teile-und-Beherrsche-Methode löst die dynamische Programmierung Probleme, indem sie die Lösungen von Teilproblemen kombiniert. Diese Teilprobleme können sich dabei überlappen,
d.h. wenn die Teilprobleme ihrerseits jeweils die gleichen Teil-Teil-probleme lösen müssen. Das DP löst jedes Teilproblem genau einmal und speichert dessen Lösung als Teilergebnis in einer Tabelle oder auch Matrix
ab. Dadurch vermeiden wir den Aufwand, die Lösung eines Teilteilproblems jedes Mal wieder neu zu berechnen, wenn es uns wieder begegnet.</p><p>Als einer der klassischen Vertreter der dynamischen Programmierung kann der Floyd-Warshall-Algorithmus das kürzeste-Pfad-Problem für alle Knotenpaare auf einen gerichteten Graphen lösen.</p><h2>Der Floyd-Warshall-Algorithmus</h2><p>Der Floyd-Warshall-Algorithmus nutzt das Prinzip der dynamischen Programmierung, um in einem gewichteten Graphen den kürzesten Pfad zwischen allen Paaren von Knoten zu berechnen.
Für alle Knoten mit dem Index k zwischen 1 und N (N ist die Anzahl der Knoten des Graphen) wird überprüft, ob der bisher bekannte Pfad zwischen Knotenpaaren verkürzt wird wenn er
über den Knoten k führt (und sich damit aus den 2 Teilpfaden von den Knoten zu k zusammensetzt) oder nicht.
Dabei wird die Matrix für jeden Knoten k von 1 bis N aufgerufen, die Veränderungen werden gespeichert und dann als Grundlage für die nächste Iteration verwendet.</p><p>Unten siehst du das gleiche Netzerk, wie rechts. Um die Adjazensmatrix des Netzwerks zu sehen, drücke <span class="idyll-action">hier</span>.<div style="width:100%"></div><button>
&lt;</button> <button>
&gt;</button></p><p>Der Pseudocode unten zeigt dir welcher Vergleich für jede Iteration gemacht wird.</p><div class="d3-component" style="width:100%"></div><h2>Resultat des Algorithmus</h2><p>Die ursprüngliche Matrix sah so aus:<div style="width:100%"></div>
Die finale Matrix sieht nun so aus:<div style="width:100%"></div></p></div></div></div></div>
    <script src="static/idyll_index.js"></script>
  </body>
</html>
