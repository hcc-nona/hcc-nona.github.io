<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
      <title>
        Netzwerk
      </title>
      <meta property="og:title" content="Netzwerk">
    <meta charset="utf-8">
    <meta property="og:type" content="article">

      <meta property="og:description" content="my description">
      <meta property="description" content="my description">


    <link rel="stylesheet" href="static/idyll_styles.css">
  </head>
  <body>
    <div id="idyll-mount"><div data-reactroot=""><div class="idyll-root"><div style="max-width:600px;margin-top:0;margin-right:0;margin-bottom:0;margin-left:50px" class=" idyll-text-container"><div class="article-header"><h1 class="hed">KÜRZESTE WEGE IN NETZWERKEN</h1><h2 class="dek">Am Beispiel des Floyd-Warshall Algorithmus</h2><div class="byline">By: <a>Duc, Thomas, Ben</a></div></div><div class="fixed"><p><h3>Klicke zwei Knoten an</h3></p><div style="width:100%"></div></div><h2>Wie du diese Seite benutzt</h2><p>Auf der rechten Seite ist ein Netzwerk. Wenn du zwei Konten anklickst, wird dir der kürzeste Pfad zwischen den beiden angezeigt.
Hier auf der linken Seite kannst du eine kurze Einführung zu Netzwerken und dem Floyd-Warshall Algorithmus lesen. Weiter unten wird
der Algorithmus visuell durchlaufen um die einzelnen Schritte zu verdeutlichen.</p><h2>Was ist ein Netzwerk?</h2><p>Ein Netzwerk besteht aus einer Menge von eindeutigen Punkten, die Knoten genannt werden.</p><p><span class="isvg pending"></span><br/>
Diese Knoten können durch sogenannte Kanten verbunden sein. Gilt die Kante zwischen zwei Knoten
für beide Richtungen, so spricht man von einem ungerichteten Graphen</p><span class="isvg pending"></span><p>Im Gegenteil kann auch eine Kante nur für eine Richtung gelten. Deshalb wird der folgende Graph auch
gerichteter Graph genannt.</p><span class="isvg pending"></span><p>Außerdem kann jede Kante ein Gewicht haben. Das nächste Bild zeigt einen vollständigen Graphen.</p><span class="isvg pending"></span><p>Jedes Netzwerk ist definiert durch die Anzahl der Knoten und die Kanten, welche sie verbinden. Dadurch kann man
zu jeden Netzwerk eine Matrix angeben, die die Verbindungen des Netzwerks abbildet. Diese Matrix wird<a url="https://de.wikipedia.org/wiki/Adjazenzmatrix" href="https://de.wikipedia.org/wiki/Adjazenzmatrix">Adjazenzmatrix</a> genannt. Der Matrixeintrag in Zeile 1 und Spalte 2
gibt das Gewicht der Verbindung von Knoten 1 zum Knoten 2 an. Gibt es keine Verbindung von 1 nach 2, wird das Gewicht als
unendlich aufgefasst.<div style="width:100%"></div></p><h2>Dynamische Programmierung</h2><p>Dynamische Programmierung ist eine Methode zum algorithmischen Lösen eines Optimierungsproblems, indem dieses in gleichartige Teilprobleme zerlegt wird und die Zwischenresultaten systematische gespeichert werden.
Wie die Teile-und-Beherrsche-Methode löst die dynamische Programmierung Probleme, indem sie die Lösungen von Teilproblemen kombiniert. Diese Teilprobleme können sich dabei überlappen,
d.h. wenn die Teilprobleme ihrerseits jeweils die gleichen Teil-Teil-probleme lösen müssen. Das DP löst jedes Teilproblem genau einmal und speichert dessen Lösung als Teilergebnis in einer Tabelle oder auch Matrix
ab. Dadurch vermeiden wir den Aufwand, die Lösung eines Teilteilproblems jedes Mal wieder neu zu berechnen, wenn es uns wieder begegnet.</p><p>Als einer der klassischen Vertreter der dynamischen Programmierung kann der Floyd-Warshall-Algorithmus das kürzeste-Pfad-Problem für alle Knotenpaare auf einen gerichteten Graphen lösen.</p><h2>Der Floyd-Warshall-Algorithmus</h2><p>Der Floyd-Warshall-Algorithmus nutzt das Prinzip der dynamischen Programmierung, um in einem gewichteten Graphen den kürzesten Pfad zwischen allen Paaren von Knoten zu berechnen.
Nehmen wir uns zum erklären das Netzwerk, welches unten zu sehen ist, als Beispiel. Zuerst wählt sich der Algorithmus den ersten Knoten als<span> <span class="yellowText">Vergleichsknoten k = 00</span></span> aus. Dann wählt er den <span> <span class="redText">Startknoten i = 01</span></span> aus und den <span> <span class="greenText">Endknoten j = 01</span></span>. Jetzt vergleicht der Algorithmus,
ob der bekannte Weg vom Startknoten zum Endknoten ein kleineres Gewicht hat, als der neue Weg vom Startknoten zum Vergleichsknoten zum Endknoten.
Da der Start- und Endknoten hier derselbe Knoten ist, ist der bekannte Weg ein einfaches Stehenbleiben mit Gewicht 0.
Das Gewicht vom  <span> <span class="redText">Startknoten i = 01</span></span> zum <span> <span class="yellowText">Vergleichsknoten k = 00</span></span> ist unendlich, denn es gibt keinen Pfad, das Gewicht von <span> <span class="yellowText">Vergleichsknoten k = 00</span></span> zum <span> <span class="redText">Startknoten i = 01</span></span> ist 3.
Somit ist das Gewicht des bekannten  Weges (Stehenbleiben) kleiner als das des neuen Weges (über den <span> <span class="yellowText">Vergleichsknoten k = 00</span></span>).
Nun wird der nächste <span> <span class="greenText">Endknoten j = 02</span></span> angeschaut und wieder verglichen. Sind alle Endknoten verglichen, wird der Startknoten gewechselt.
Sind für jeden Startknoten alle Endknoten verglichen, wird der Vergleichsknoten gewechselt. Alle Veränderungen (neue kürzeste Pfade) werden gespeichert.</p><p>Unten siehst du das gleiche Netzerk, wie rechts. Um die Adjazensmatrix des Netzwerks zu sehen, drücke <span class="idyll-action">hier</span>.
Unter dem Netzwerk ist der Pseudocode zu dem Algorithmus angezeigt. Er zeigt an, welcher Vergleich gerade gemacht wird.</p><p><button>
&lt;</button>       <button>
&gt;</button></p><div style="width:100%"></div><div class="d3-component" style="width:100%"></div><p>Nachdem du ein paar Schritte durchgegangen bist, hast du das Prinzip bestimmt verstanden. Wir hoffen mit der Visualisierung
geholfen zu haben!</p><h2>Resultat des Algorithmus</h2><p>Die ursprüngliche Matrix sah so aus:<div style="width:100%"></div>
Die finale Matrix sieht nun so aus:<div style="width:100%"></div></p><p>Lizenz: <a url="https://creativecommons.org/licenses/by-sa/4.0/legalcode" href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC-BY-SA 4.0 international</a></p></div></div></div></div>
    <script src="static/idyll_index.js"></script>
  </body>
</html>
